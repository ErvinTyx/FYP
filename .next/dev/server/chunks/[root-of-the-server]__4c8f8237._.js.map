{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///home/ervin/Documents/Power%20Metal%20%26%20Steel/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { PrismaMariaDb } from \"@prisma/adapter-mariadb\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nfunction createPrismaClient() {\n  const adapter = new PrismaMariaDb({\n    host: process.env.DATABASE_HOST || \"localhost\",\n    port: Number(process.env.DATABASE_PORT || 3306),\n    user: process.env.DATABASE_USER || \"root\",\n    password: process.env.DATABASE_PASSWORD || \"\",\n    database: process.env.DATABASE_NAME || \"power_metal_steel\",\n    connectionLimit: 5,\n  });\n  return new PrismaClient({ adapter });\n}\n\nexport const prisma = globalForPrisma.prisma ?? createPrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") {\n  globalForPrisma.prisma = prisma;\n}\n\nexport default prisma;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA,MAAM,kBAAkB;AAIxB,SAAS;IACP,MAAM,UAAU,IAAI,mLAAa,CAAC;QAChC,MAAM,QAAQ,GAAG,CAAC,aAAa,IAAI;QACnC,MAAM,OAAO,QAAQ,GAAG,CAAC,aAAa,IAAI;QAC1C,MAAM,QAAQ,GAAG,CAAC,aAAa,IAAI;QACnC,UAAU,QAAQ,GAAG,CAAC,iBAAiB,IAAI;QAC3C,UAAU,QAAQ,GAAG,CAAC,aAAa,IAAI;QACvC,iBAAiB;IACnB;IACA,OAAO,IAAI,sMAAY,CAAC;QAAE;IAAQ;AACpC;AAEO,MAAM,SAAS,gBAAgB,MAAM,IAAI;AAEhD,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B;uCAEe"}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["file:///home/ervin/Documents/Power%20Metal%20%26%20Steel/src/lib/auth.ts"],"sourcesContent":["import NextAuth, { type DefaultSession } from \"next-auth\";\nimport Credentials from \"next-auth/providers/credentials\";\nimport bcrypt from \"bcrypt\";\nimport { prisma } from \"./prisma\";\nimport type { Role } from \"./roles\";\n\ndeclare module \"next-auth\" {\n  interface User {\n    id: string;\n    email: string;\n    name?: string | null;\n    roles: Role[];\n  }\n\n  interface Session {\n    user: {\n      id: string;\n      email: string;\n      name?: string | null;\n      roles: Role[];\n    } & DefaultSession[\"user\"];\n  }\n}\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  providers: [\n    Credentials({\n      name: \"credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const email = credentials.email as string;\n        const password = credentials.password as string;\n\n        // Find user with roles\n        const user = await prisma.user.findUnique({\n          where: { email },\n          include: {\n            roles: {\n              include: {\n                role: true,\n              },\n            },\n          },\n        });\n\n        if (!user) {\n          return null;\n        }\n\n        // Verify password\n        const isValidPassword = await bcrypt.compare(password, user.password);\n        if (!isValidPassword) {\n          return null;\n        }\n\n        // Extract role names\n        const roles = user.roles.map((ur) => ur.role.name as Role);\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          roles,\n        };\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n        token.roles = user.roles;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token) {\n        session.user.id = token.id as string;\n        session.user.roles = token.roles as Role[];\n      }\n      return session;\n    },\n  },\n  pages: {\n    signIn: \"/login\",\n    error: \"/login\",\n  },\n  session: {\n    strategy: \"jwt\",\n    maxAge: 24 * 60 * 60, // 24 hours\n  },\n  secret: process.env.AUTH_SECRET,\n});\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;;;;;AAqBO,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,kKAAQ,EAAC;IAC1D,WAAW;QACT,IAAA,uMAAW,EAAC;YACV,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,QAAQ,YAAY,KAAK;gBAC/B,MAAM,WAAW,YAAY,QAAQ;gBAErC,uBAAuB;gBACvB,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE;oBAAM;oBACf,SAAS;wBACP,OAAO;4BACL,SAAS;gCACP,MAAM;4BACR;wBACF;oBACF;gBACF;gBAEA,IAAI,CAAC,MAAM;oBACT,OAAO;gBACT;gBAEA,kBAAkB;gBAClB,MAAM,kBAAkB,MAAM,6JAAM,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ;gBACpE,IAAI,CAAC,iBAAiB;oBACpB,OAAO;gBACT;gBAEA,qBAAqB;gBACrB,MAAM,QAAQ,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,KAAO,GAAG,IAAI,CAAC,IAAI;gBAEjD,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf;gBACF;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,KAAK,GAAG,KAAK,KAAK;YAC1B;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,OAAO;gBACT,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,KAAK;YAClC;YACA,OAAO;QACT;IACF;IACA,OAAO;QACL,QAAQ;QACR,OAAO;IACT;IACA,SAAS;QACP,UAAU;QACV,QAAQ,KAAK,KAAK;IACpB;IACA,QAAQ,QAAQ,GAAG,CAAC,WAAW;AACjC"}},
    {"offset": {"line": 246, "column": 0}, "map": {"version":3,"sources":["file:///home/ervin/Documents/Power%20Metal%20%26%20Steel/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import { handlers } from \"@/lib/auth\";\n\nexport const { GET, POST } = handlers;\n"],"names":[],"mappings":";;;;;;AAAA;;AAEO,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,gIAAQ"}}]
}