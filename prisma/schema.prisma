generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
}

model User {
  id                  String               @id @default(cuid())
  email               String               @unique
  password            String
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  firstName           String?
  lastName            String?
  phone               String?              @unique
  status              String               @default("pending")
  customer            Customer?
  passwordSetupTokens PasswordSetupToken[]
  roles               UserRole[]
}

model Customer {
  id                  String   @id                          // Same as User.id (1-to-1 relation)
  user                User     @relation(fields: [id], references: [id], onDelete: Cascade)
  
  customerType        String                                // 'individual' or 'business'
  tin                 String                                // Tax Identification Number
  idType              String                                // 'NRIC', 'PASSPORT', 'ARMY' (individual) or 'BRN' (business)
  idNumber            String?                               // ID number: NRIC/Passport/Army for individual, BRN for business
  identityDocumentUrl String?                               // Identity supporting document path
  rejectionReason     String?                               // Reason if rejected by admin
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

model VerificationCode {
  id        String   @id @default(cuid())
  email     String
  code      String
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
}

model PasswordSetupToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "PasswordSetupToken_userId_fkey")
}

model Role {
  id        String     @id @default(cuid())
  name      String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  users     UserRole[]
}

model UserRole {
  userId String
  roleId String
  user   User   @relation(fields: [userId], references: [id])
  role   Role   @relation(fields: [roleId], references: [id])

  @@id([userId, roleId])
  @@index([roleId], map: "UserRole_roleId_fkey")
}

model ContentItem {
  id        String   @id @default(cuid())
  type      String   // about, faq, terms, delivery-zones, banners, safety, announcements, permits, site-access, blogs
  title     String
  content   String   @db.Text
  status    String   @default("draft") // published, draft
  imageUrl  String?  @db.Text // For storing uploaded image URLs
  metadata  String?  @db.Text // JSON string for category-specific data (question/answer, zone/price, priority, etc.)
  updatedBy String   @default("System")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([status])
}

// ============================================
// RFQ & QUOTATION MODELS
// ============================================

model rFQ {
  id                String            @id @default(cuid())
  rfqNumber         String            @unique
  customerName      String
  customerEmail     String
  customerPhone     String
  projectName       String
  projectLocation   String
  requestedDate     DateTime
  requiredDate      DateTime
  status            String            @default("draft")
  totalAmount       Decimal           @default(0) @db.Decimal(15, 2)
  notes             String?           @db.LongText
  createdBy         String
  items             rFQItem[]
  deliveryRequests  DeliveryRequest[]
  returnRequests    ReturnRequest[]
  rentalAgreements  RentalAgreement[]
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
}

model rFQItem {
  id                    String     @id @default(cuid())
  rfqId                 String
  rfq                   rFQ        @relation(fields: [rfqId], references: [id], onDelete: Cascade)
  setName               String     @default("Set 1")
  deliverDate           DateTime?
  returnDate            DateTime?
  durationDays          Int?       // returnDate - deliverDate (days), set on create/update
  scaffoldingItemId     String
  scaffoldingItemName   String
  quantity              Int
  unit                  String
  unitPrice             Decimal    @db.Decimal(15, 2)
  totalPrice            Decimal    @db.Decimal(15, 2)
  notes                 String?    @db.Text
  createdAt             DateTime   @default(now())
  updatedAt             DateTime   @updatedAt

  @@index([rfqId], map: "rFQItem_rfqId_fkey")
}

// Inspection & Maintenance Module - Condition Report
model ConditionReport {
  id                    String                @id @default(cuid())
  rcfNumber             String                @unique
  deliveryOrderNumber   String
  customerName          String
  returnedBy            String?
  returnDate            String
  inspectionDate        String
  inspectedBy           String
  status                String                @default("pending")
  totalItemsInspected   Int                   @default(0)
  totalGood             Int                   @default(0)
  totalRepair           Int                   @default(0)
  totalWriteOff         Int                   @default(0)
  totalDamaged          Int                   @default(0)
  totalRepairCost       Decimal               @default(0) @db.Decimal(15, 2)
  notes                 String?               @db.LongText
  items                 InspectionItem[]
  inventoryAdjustments  InventoryAdjustment[]
  openRepairSlips       OpenRepairSlip[]
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  
  // Link to Return Request (auto-created from return workflow)
  returnRequestId       String?               @unique
  returnRequest         ReturnRequest?        @relation(fields: [returnRequestId], references: [id], onDelete: SetNull)
}

model InspectionItem {
  id                    String           @id @default(cuid())
  conditionReportId     String
  conditionReport       ConditionReport  @relation(fields: [conditionReportId], references: [id], onDelete: Cascade)
  scaffoldingItemId     String
  scaffoldingItemName   String
  quantity              Int
  quantityGood          Int              @default(0)
  quantityRepair        Int              @default(0)
  quantityWriteOff      Int              @default(0)
  condition             String           @default("good")
  damageDescription     String?          @db.Text
  repairRequired        Boolean          @default(false)
  estimatedRepairCost   Decimal          @default(0) @db.Decimal(15, 2)
  originalItemPrice     Decimal          @default(0) @db.Decimal(15, 2)
  inspectionChecklist   String?          @db.LongText
  images                String?          @db.LongText
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
}

// Inspection & Maintenance Module - Open Repair Slip
model OpenRepairSlip {
  id                    String               @id @default(cuid())
  orpNumber             String               @unique
  conditionReportId     String
  conditionReport       ConditionReport      @relation(fields: [conditionReportId], references: [id], onDelete: Cascade)
  rcfNumber             String
  status                String               @default("open") // open, in-repair, completed, cancelled
  priority              String               @default("medium") // low, medium, high, urgent
  assignedTo            String?
  startDate             String?
  completionDate        String?
  estimatedCost         Decimal              @default(0) @db.Decimal(15, 2)
  actualCost            Decimal              @default(0) @db.Decimal(15, 2)
  repairNotes           String?              @db.LongText
  invoiceNumber         String?
  damageInvoiceId       String?
  createdBy             String
  inventoryLevel        String?              // very-low, low, normal, high
  items                 RepairItem[]
  inventoryAdjustments  InventoryAdjustment[]
  additionalCharge      AdditionalCharge?    // reverse 1:1 – charge has openRepairSlipId
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
}

model RepairItem {
  id                    String               @id @default(cuid())
  openRepairSlipId      String
  openRepairSlip        OpenRepairSlip       @relation(fields: [openRepairSlipId], references: [id], onDelete: Cascade)
  inspectionItemId      String?
  scaffoldingItemId     String
  scaffoldingItemName   String
  quantity              Int
  quantityRepair        Int                  @default(0)  // Items for repair
  quantityWriteOff      Int                  @default(0)  // Items for write-off (beyond repair)
  quantityRepaired      Int                  @default(0)
  quantityRemaining     Int                  @default(0)
  damageType            String               // bent, cracked, corroded, missing-parts, welding-required, other
  damageDescription     String?              @db.Text
  repairActions         String?              @db.LongText // JSON array of repair action names (legacy)
  repairActionEntries   String?              @db.LongText // JSON array of RepairActionEntry: {id, action, affectedItems, issueQuantity, costPerUnit, totalCost}
  repairDescription     String?              @db.Text
  repairStatus          String               @default("pending") // pending, in-progress, completed
  // Cost fields
  writeOffCostPerUnit   Decimal              @default(0) @db.Decimal(15, 2) // Original price of scaffolding item
  writeOffTotalCost     Decimal              @default(0) @db.Decimal(15, 2) // quantityWriteOff × writeOffCostPerUnit
  totalRepairCost       Decimal              @default(0) @db.Decimal(15, 2) // Sum of all repair action entry costs
  costPerUnit           Decimal              @default(0) @db.Decimal(15, 2) // Legacy
  totalCost             Decimal              @default(0) @db.Decimal(15, 2) // totalRepairCost + writeOffTotalCost
  estimatedCostFromRFQ  Decimal              @default(0) @db.Decimal(15, 2)
  finalCost             Decimal              @default(0) @db.Decimal(15, 2)
  beforeImages          String?              @db.LongText // JSON array of image URLs
  afterImages           String?              @db.LongText // JSON array of image URLs
  completedDate         String?
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
}

// Inspection & Maintenance Module - Damage Invoice
model DamageInvoice {
  id              String        @id @default(cuid())
  invoiceNumber   String        @unique
  orpNumber       String
  invoiceDate     String
  vendor          String?
  items           InvoiceItem[]
  subtotal        Decimal       @default(0) @db.Decimal(15, 2)
  tax             Decimal       @default(0) @db.Decimal(15, 2)
  total           Decimal       @default(0) @db.Decimal(15, 2)
  paymentStatus   String        @default("pending")
  paidDate        String?
  notes           String?       @db.LongText
  createdFrom     String        @default("repair-slip")
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

model InvoiceItem {
  id                    String               @id @default(cuid())
  damageInvoiceId       String
  damageInvoice         DamageInvoice        @relation(fields: [damageInvoiceId], references: [id], onDelete: Cascade)
  description           String
  quantity              Int
  unitPrice             Decimal              @db.Decimal(15, 2)
  total                 Decimal              @db.Decimal(15, 2)
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
}

model InventoryAdjustment {
  id                    String               @id @default(cuid())
  adjustmentType        String
  conditionReportId     String?
  conditionReport       ConditionReport?     @relation(fields: [conditionReportId], references: [id], onDelete: SetNull)
  repairSlipId          String?
  repairSlip            OpenRepairSlip?      @relation(fields: [repairSlipId], references: [id], onDelete: SetNull)
  scaffoldingItemId     String
  scaffoldingItemName   String
  quantity              Int
  fromStatus            String
  toStatus              String
  referenceId           String
  referenceType         String
  adjustedBy            String
  adjustedAt            String
  notes                 String?              @db.Text
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
}

// Additional Charges (Billing & Payments) – one-to-one with OpenRepairSlip via openRepairSlipId on charge
// Also linked from Delivery & Return when quotation with fee is agreed (deliverySetId, returnRequestId)
model AdditionalCharge {
  id                  String                 @id @default(cuid())
  invoiceNo           String                 @unique
  openRepairSlipId     String?                @unique
  openRepairSlip       OpenRepairSlip?        @relation(fields: [openRepairSlipId], references: [id], onDelete: SetNull)
  returnRequestId     String?                @unique
  deliverySetId       String?                @unique
  conditionReportId   String?
  customerName         String
  doId                 String
  returnedDate         String?
  dueDate              DateTime
  status               String                 @default("pending_payment") // pending_payment, pending_approval, approved, rejected
  totalCharges         Decimal                @default(0) @db.Decimal(15, 2)
  proofOfPaymentUrl   String?                @db.Text
  referenceId          String?                @db.Text
  rejectionReason      String?                @db.Text
  approvalDate         DateTime?
  rejectionDate        DateTime?
  uploadedByEmail      String?                @db.Text
  items                AdditionalChargeItem[]
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt

  @@index([openRepairSlipId])
  @@index([returnRequestId])
  @@index([deliverySetId])
  @@index([status])
}

model AdditionalChargeItem {
  id                  String            @id @default(cuid())
  additionalChargeId  String
  additionalCharge    AdditionalCharge   @relation(fields: [additionalChargeId], references: [id], onDelete: Cascade)
  itemName            String
  itemType            String             // Damage, Repair
  repairDescription   String?            @db.Text
  quantity            Int
  unitPrice           Decimal            @db.Decimal(15, 2)
  amount              Decimal            @db.Decimal(15, 2)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  @@index([additionalChargeId])
}

//Rental Agreements
model RentalAgreement {
  id                       String    @id @default(cuid())
  agreementNumber          String    @unique
  poNumber                 String?
  projectName              String
  owner                    String
  ownerPhone               String?
  hirer                    String
  hirerPhone               String?
  location                 String?
  termOfHire               String?
  transportation           String?
  monthlyRental            Decimal   @default(0)
  securityDeposit          Decimal   @default(0)
  minimumCharges           Decimal   @default(0)
  defaultInterest          Decimal   @default(0)
  ownerSignatoryName       String?
  ownerNRIC                String?
  hirerSignatoryName       String?
  hirerNRIC                String?
  ownerSignature           String?   @db.Text
  hirerSignature           String?   @db.Text
  ownerSignatureDate       DateTime?
  hirerSignatureDate       DateTime?
  signedDocumentUrl        String?
  signedDocumentUploadedAt DateTime?
  signedDocumentUploadedBy String?
  signedStatus             String?   // "completed" when signed file uploaded, null by default
  status                   String    @default("Draft")
  currentVersion           Int       @default(1)
  createdBy                String?
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  // Link to quotation
  rfqId    String?
  rfq      rFQ?    @relation(fields: [rfqId], references: [id])

  versions           AgreementVersion[]
  deposits           Deposit[]
  monthlyInvoices    MonthlyRentalInvoice[]
  closureRequests    ProjectClosureRequest[]
}

// Project closure request (one per agreement when user requests closure; PCR-YYYY-NNN)
model ProjectClosureRequest {
  id                    String   @id @default(cuid())
  closureRequestNumber  String   @unique // e.g. PCR-2026-001
  agreementId           String
  agreement             RentalAgreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)
  requestDate           DateTime
  status                String   @default("pending") // active | pending | approved
  approvedBy            String?
  approvedAt            DateTime?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([agreementId])
}

model AgreementVersion {
  id            String   @id @default(cuid())
  versionNumber Int
  changes       String?
  allowedRoles  String?  @db.Text // JSON string of roles
  createdBy     String?
  createdAt     DateTime @default(now())
  snapshot      Json?    // agreement state at this version (so v1 stays v1 after edit)

  agreementId String
  agreement   RentalAgreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)
}

// Delivery & Return Models
model DeliveryRequest {
  id              String        @id @default(cuid())
  requestId       String        @unique
  customerName    String
  agreementNo     String
  customerPhone   String?
  customerEmail   String?
  deliveryAddress String
  deliveryType    String
  requestDate     DateTime      @default(now())
  totalSets       Int           @default(0)
  deliveredSets   Int           @default(0)
  pickupTime      String?
  rfqId           String?
  rfq             rFQ?          @relation(fields: [rfqId], references: [id])
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  sets            DeliverySet[]
  monthlyInvoices MonthlyRentalInvoice[]
}

// Main Delivery Set table - only id, status, and basic info
model DeliverySet {
  id                String            @id @default(cuid())
  setName           String
  scheduledPeriod   String
  status            String            @default("Pending") // Pending, Packing List Issued, Stock Checked, Packing & Loading, In Transit, Ready for Pickup, Completed
  quotedAmount      Decimal?
  deliveryFee       Decimal?
  deliveryRequestId String
  deliveryRequest   DeliveryRequest   @relation(fields: [deliveryRequestId], references: [id], onDelete: Cascade)
  items             DeliverySetItem[]
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  createdBy         String?
  notes             String?

  // Relations to step tables
  packingList       DeliveryPackingList?
  stockCheck        DeliveryStockCheck?
  schedule          DeliverySchedule?
  packingLoading    DeliveryPackingLoading?
  dispatch          DeliveryDispatch?
  doIssued          DeliveryDOIssued?
  completion        DeliveryCompletion?
  customerAck       DeliveryCustomerAck?
}

// Step 1: Packing List
model DeliveryPackingList {
  id                String      @id @default(cuid())
  deliverySetId     String      @unique
  deliverySet       DeliverySet @relation(fields: [deliverySetId], references: [id], onDelete: Cascade)
  packingListNumber String?
  packingListDate   DateTime?
  issuedBy          String?
  issuedAt          DateTime?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
}

// Step 2: Stock Check
model DeliveryStockCheck {
  id                String      @id @default(cuid())
  deliverySetId     String      @unique
  deliverySet       DeliverySet @relation(fields: [deliverySetId], references: [id], onDelete: Cascade)
  checkDate         DateTime?
  checkedBy         String?
  notes             String?
  allItemsAvailable Boolean?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
}

// Step 3: Schedule
model DeliverySchedule {
  id                String      @id @default(cuid())
  deliverySetId     String      @unique
  deliverySet       DeliverySet @relation(fields: [deliverySetId], references: [id], onDelete: Cascade)
  scheduledDate     DateTime?
  scheduledTimeSlot String?
  confirmedAt       DateTime?
  confirmedBy       String?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
}

// Step 4: Packing & Loading
model DeliveryPackingLoading {
  id                 String      @id @default(cuid())
  deliverySetId      String      @unique
  deliverySet        DeliverySet @relation(fields: [deliverySetId], references: [id], onDelete: Cascade)
  packingStartedAt   DateTime?
  packingStartedBy   String?
  loadingCompletedAt DateTime?
  loadingCompletedBy String?
  packingPhotos      Json?
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
}

// Step 5: Dispatch (Driver Info)
model DeliveryDispatch {
  id                   String      @id @default(cuid())
  deliverySetId        String      @unique
  deliverySet          DeliverySet @relation(fields: [deliverySetId], references: [id], onDelete: Cascade)
  driverName           String?
  driverContact        String?
  vehicleNumber        String?
  driverSignature      String?   @db.Text
  driverAcknowledgedAt DateTime?
  dispatchedAt         DateTime?
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt
}

// Step 6: DO Issued
model DeliveryDOIssued {
  id            String      @id @default(cuid())
  deliverySetId String      @unique
  deliverySet   DeliverySet @relation(fields: [deliverySetId], references: [id], onDelete: Cascade)
  doNumber      String?
  doIssuedAt    DateTime?
  doIssuedBy    String?
  signedDO      String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

// Step 7: Delivery Completion
model DeliveryCompletion {
  id             String      @id @default(cuid())
  deliverySetId  String      @unique
  deliverySet    DeliverySet @relation(fields: [deliverySetId], references: [id], onDelete: Cascade)
  deliveredAt    DateTime?
  deliveryPhotos Json?
  deliveredBy    String?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
}

// Step 8: Customer Acknowledgement
model DeliveryCustomerAck {
  id                     String      @id @default(cuid())
  deliverySetId          String      @unique
  deliverySet            DeliverySet @relation(fields: [deliverySetId], references: [id], onDelete: Cascade)
  customerAcknowledgedAt DateTime?
  customerSignature      String?   @db.Text
  customerSignedBy       String?
  customerOTP            String?
  verifiedOTP            Boolean?
  inventoryUpdatedAt     DateTime?
  inventoryStatus        String?
  createdAt              DateTime    @default(now())
  updatedAt              DateTime    @updatedAt
}

model DeliverySetItem {
  id                String      @id @default(cuid())
  name              String
  quantity          Int
  scaffoldingItemId String?
  deliverySetId     String
  deliverySet       DeliverySet @relation(fields: [deliverySetId], references: [id], onDelete: Cascade)
}

// Main Return Request table - only id, status, and basic request info
model ReturnRequest {
  id               String              @id @default(cuid())
  requestId        String              @unique
  customerName     String
  agreementNo      String
  setName          String
  requestDate      DateTime            @default(now())
  status           String              @default("Requested") // Requested, Approved, Pickup Scheduled, Pickup Confirmed, Driver Recording, In Transit, Received at Warehouse, Under Inspection, Sorting Complete, Customer Notified, Dispute Raised, Completed
  reason           String
  pickupAddress    String
  customerPhone    String?
  customerEmail    String?
  pickupFee        Decimal?
  returnType       String              // Partial, Full
  collectionMethod String              // Self Return, Transportation Needed
  rfqId            String?
  rfq              rFQ?                @relation(fields: [rfqId], references: [id])
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  items            ReturnRequestItem[]

  // Relations to step tables
  schedule         ReturnSchedule?
  pickupConfirm    ReturnPickupConfirm?
  driverRecording  ReturnDriverRecording?
  warehouseReceipt ReturnWarehouseReceipt?
  inspection       ReturnInspection?
  rcf              ReturnRCF?
  notification     ReturnNotification?
  completion       ReturnCompletion?
  
  // Link to Inspection Module - auto-created Condition Report
  conditionReport  ConditionReport?
}

model ReturnRequestItem {
  id                String                 @id @default(cuid())
  name              String
  quantity          Int                    // Original quantity from rental agreement
  quantityReturned  Int                    @default(0) // Total quantity being returned
  notes             String?
  scaffoldingItemId String?
  returnRequestId   String
  returnRequest     ReturnRequest          @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  conditions        ReturnItemCondition[]  // Normalized breakdown by condition status (Good, Damaged, Replace)
}

// Stores quantity breakdown by condition status for each return item
// e.g., Item A: 5 Good, 3 Damaged, 2 Replace
model ReturnItemCondition {
  id                  String            @id @default(cuid())
  returnRequestItemId String
  returnRequestItem   ReturnRequestItem @relation(fields: [returnRequestItemId], references: [id], onDelete: Cascade)
  status              String            // "Good", "Damaged", "Replace"
  quantity            Int               @default(0)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  @@unique([returnRequestItemId, status]) // One record per status per item
}

// Step 1: Schedule/Approval
model ReturnSchedule {
  id              String        @id @default(cuid())
  returnRequestId String        @unique
  returnRequest   ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  scheduledDate   DateTime?
  timeSlot        String?
  approvedAt      DateTime?
  approvedBy      String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

// Step 2: Pickup Confirmation (for Transportation Needed)
model ReturnPickupConfirm {
  id              String        @id @default(cuid())
  returnRequestId String        @unique
  returnRequest   ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  pickupDriver    String?
  driverContact   String?
  confirmedAt     DateTime?
  confirmedBy     String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

// Step 3: Driver Recording (for Transportation Needed)
model ReturnDriverRecording {
  id              String        @id @default(cuid())
  returnRequestId String        @unique
  returnRequest   ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  driverPhotos    Json?
  recordedAt      DateTime?
  recordedBy      String?
  inTransitAt     DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

// Step 4: Warehouse Receipt
model ReturnWarehouseReceipt {
  id              String        @id @default(cuid())
  returnRequestId String        @unique
  returnRequest   ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  warehousePhotos Json?
  receivedAt      DateTime?
  receivedBy      String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

// Step 5: Inspection & GRN
model ReturnInspection {
  id               String        @id @default(cuid())
  returnRequestId  String        @unique
  returnRequest    ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  grnNumber        String?
  inspectedAt      DateTime?
  inspectedBy      String?
  productionNotes  String?
  hasExternalGoods Boolean       @default(false)
  externalGoodsNotes String?
  damagePhotos     Json?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
}

// Step 6: RCF Generation
model ReturnRCF {
  id              String        @id @default(cuid())
  returnRequestId String        @unique
  returnRequest   ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  rcfNumber       String?
  generatedAt     DateTime?
  generatedBy     String?
  skipped         Boolean       @default(false)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

// Step 7: Customer Notification
model ReturnNotification {
  id              String        @id @default(cuid())
  returnRequestId String        @unique
  returnRequest   ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  notificationSent Boolean      @default(false)
  notifiedAt      DateTime?
  notifiedBy      String?
  disputeRaised   Boolean       @default(false)
  disputeDescription String?
  disputeRaisedAt DateTime?
  disputeResolved Boolean       @default(false)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

// Step 8: Completion
model ReturnCompletion {
  id               String        @id @default(cuid())
  returnRequestId  String        @unique
  returnRequest    ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  inventoryUpdated Boolean       @default(false)
  soaUpdated       Boolean       @default(false)
  completedAt      DateTime?
  completedBy      String?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
}

// ScaffoldingItem model for inventory management
model ScaffoldingItem {
  id            String                    @id @default(cuid())
  itemCode      String                    @unique
  name          String
  category      String
  available     Int                       @default(0)
  price         Decimal                   @default(0)
  originPrice   Decimal?                  @default(0)
  status        String                    @default("Available")
  location      String?
  itemStatus    String                    @default("Available")
  imageUrl      String?
  createdAt     DateTime                  @default(now())
  updatedAt     DateTime                  @updatedAt
  damageRepairs ScaffoldingDamageRepair[]
}

// Damage and repair entries for scaffolding items (separate table for easier querying/reporting)
model ScaffoldingDamageRepair {
  id                    String         @id @default(cuid())
  scaffoldingItemId     String
  scaffoldingItem       ScaffoldingItem @relation(fields: [scaffoldingItemId], references: [id], onDelete: Cascade)
  description           String         @db.Text
  repairChargePerUnit   Decimal        @default(0) @db.Decimal(10, 2)
  partsLabourCostPerUnit Decimal       @default(0) @db.Decimal(10, 2)
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  @@index([scaffoldingItemId])
}

// ============================================
// DEPOSIT MODULE
// ============================================

// Deposit model for tracking security deposits with payment workflow
model Deposit {
  id                      String    @id @default(cuid())
  depositNumber           String    @unique // DEP-YYYYMMDD-XXX format
  
  // Link to agreement
  agreementId             String
  agreement               RentalAgreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)
  
  // Deposit details
  depositAmount           Decimal   @db.Decimal(15, 2)
  status                  String    @default("Pending Payment") // Pending Payment, Pending Approval, Paid, Rejected, Overdue, Expired
  dueDate                 DateTime
  
  // Payment proof
  paymentProofUrl         String?
  paymentProofFileName    String?
  paymentProofUploadedAt  DateTime?
  paymentProofUploadedBy  String?
  paymentSubmittedAt      DateTime?
  
  // Approval
  approvedBy              String?
  approvedAt              DateTime?
  referenceNumber         String?   // Bank reference number entered on approval
  
  // Rejection
  rejectedBy              String?
  rejectedAt              DateTime?
  rejectionReason         String?   @db.Text
  
  // Timestamps
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
}

// Monthly Rental Billing
model MonthlyRentalInvoice {
  id                      String    @id @default(cuid())
  invoiceNumber           String    @unique  // MRI-YYYYMMDD-XXX
  
  // Links
  deliveryRequestId       String
  deliveryRequest         DeliveryRequest @relation(fields: [deliveryRequestId], references: [id])
  agreementId             String?
  agreement               RentalAgreement? @relation(fields: [agreementId], references: [id])
  
  // Customer Info (snapshot)
  customerName            String
  customerEmail           String?
  customerPhone           String?
  
  // Billing Period
  billingMonth            Int       // 1-12
  billingYear             Int
  billingStartDate        DateTime
  billingEndDate          DateTime
  daysInPeriod            Int
  
  // Amount Calculation
  baseAmount              Decimal   @db.Decimal(15, 2)  // items × unitPrice × days
  overdueCharges          Decimal   @default(0) @db.Decimal(15, 2)
  totalAmount             Decimal   @db.Decimal(15, 2)
  
  // Status & Payment
  status                  String    @default("Pending Payment") // Pending Payment, Pending Approval, Paid, Rejected, Overdue
  dueDate                 DateTime
  
  // Payment Proof
  paymentProofUrl         String?
  paymentProofFileName    String?
  paymentProofUploadedAt  DateTime?
  paymentProofUploadedBy  String?
  
  // Approval
  approvedBy              String?
  approvedAt              DateTime?
  referenceNumber         String?
  
  // Rejection
  rejectedBy              String?
  rejectedAt              DateTime?
  rejectionReason         String?   @db.Text
  
  // Invoice Items (snapshot of what was billed)
  items                   MonthlyRentalInvoiceItem[]
  
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
}

model MonthlyRentalInvoiceItem {
  id                      String    @id @default(cuid())
  invoiceId               String
  invoice                 MonthlyRentalInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  
  scaffoldingItemId       String
  scaffoldingItemName     String
  quantityBilled          Int       // quantity still out at billing time
  unitPrice               Decimal   @db.Decimal(15, 2)
  daysCharged             Int
  lineTotal               Decimal   @db.Decimal(15, 2)  // qty × unitPrice × days
  
  createdAt               DateTime  @default(now())
}

// ============================================
// CREDIT NOTE MODULE
// ============================================

model CreditNote {
  id                      String    @id @default(cuid())
  creditNoteNumber        String    @unique // CN-YYYY-XXX format
  
  // Customer Info
  customerName            String
  customerId              String
  
  // Reference
  invoiceType             String    @default("monthlyRental") // deposit, monthlyRental, additionalCharge
  sourceId                String?  // id of Deposit, MonthlyRentalInvoice, or AdditionalCharge
  originalInvoice         String
  deliveryOrderId         String?
  
  // Credit Note Details
  amount                  Decimal   @db.Decimal(15, 2)
  reason                  String    // 'Returned Items', 'Price Adjustment', 'Service Issue', 'Damaged Goods', 'Billing Error', 'Other'
  reasonDescription       String?   @db.Text
  date                    DateTime
  
  // Status & Workflow
  status                  String    @default("Draft") // Draft, Pending Approval, Approved, Rejected
  
  // Created By
  createdBy               String
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  
  // Approval
  approvedBy              String?
  approvedAt              DateTime?
  
  // Rejection
  rejectedBy              String?
  rejectedAt              DateTime?
  rejectionReason         String?   @db.Text
  
  // Relations
  items                   CreditNoteItem[]
  attachments             CreditNoteAttachment[]
}

model CreditNoteItem {
  id                      String    @id @default(cuid())
  creditNoteId            String
  creditNote              CreditNote @relation(fields: [creditNoteId], references: [id], onDelete: Cascade)
  
  description             String
  quantity                Int
  previousPrice           Decimal   @db.Decimal(15, 2)  // Price from DO
  currentPrice            Decimal   @db.Decimal(15, 2)  // Price from Invoice
  unitPrice               Decimal   @db.Decimal(15, 2)  // Legacy compatibility
  amount                  Decimal   @db.Decimal(15, 2)  // Calculated: quantity × currentPrice
  daysCharged             Int?      // For monthly rental / additional charge line items
  
  createdAt               DateTime  @default(now())
}

model CreditNoteAttachment {
  id                      String    @id @default(cuid())
  creditNoteId            String
  creditNote              CreditNote @relation(fields: [creditNoteId], references: [id], onDelete: Cascade)
  
  fileName                String
  fileUrl                 String
  fileSize                Int
  uploadedAt              DateTime  @default(now())
}

// ============================================
// REFUND MODULE
// ============================================

model Refund {
  id                      String    @id @default(cuid())
  refundNumber            String    @unique // REF-YYYY-XXX
  invoiceType             String    // deposit, monthlyRental, additionalCharge
  sourceId                String    // id of Deposit, MonthlyRentalInvoice, or AdditionalCharge
  originalInvoice         String
  customerName            String
  customerId              String
  amount                  Decimal   @db.Decimal(15, 2)
  refundMethod            String?   // Bank Transfer, eWallet, Cash
  reason                  String?   @db.Text
  reasonDescription       String?   @db.Text
  status                  String    @default("Draft") // Draft, Pending Approval, Approved, Rejected
  createdBy               String
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  approvedBy              String?
  approvedAt              DateTime?
  rejectedBy              String?
  rejectedAt              DateTime?
  rejectionReason         String?   @db.Text
  attachments             RefundAttachment[]
}

model RefundAttachment {
  id                      String    @id @default(cuid())
  refundId                String
  refund                  Refund    @relation(fields: [refundId], references: [id], onDelete: Cascade)
  fileName                String
  fileUrl                 String
  fileSize                Int
  uploadedAt              DateTime  @default(now())
}

// ============================================
// NOTIFICATION MODULE
// ============================================

model RFQNotification {
  id                      String    @id @default(cuid())
  rfqId                   String
  rfqNumber               String
  
  type                    String    // 'created', 'updated', 'item_added', 'item_removed', 'item_modified', 'status_changed', 'assigned'
  message                 String
  changes                 String?   @db.LongText  // JSON array of changes
  
  createdBy               String
  createdAt               DateTime  @default(now())
  read                    Boolean   @default(false)
}
